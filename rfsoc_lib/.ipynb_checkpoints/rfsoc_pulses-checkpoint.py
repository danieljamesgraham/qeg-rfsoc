# TODO: Allow gain up to 32566 when no arb

import numpy as np
import bisect

class RfsocPulses():

    def __init__(self, imported_seqs, ch_map=None, gains={}, delays={}, const_power=None, scale_power=1, print_params=False):
        """
        Constructor method.
        Creates and prints dictionary containing all specified pulse sequence 
        parameters for each channel.

        Parameters
        ----------
        imported_seqs : list
            Pulse sequences to be generated by DACs and DIG outputs.
        ch_map : dict, optional
            Map names of pulse sequences to channels on board.
        gains : dict, optional
            Specify gain of DACs in arbitrary units [0, 32765], overriding DEFAULT_GAIN.
        delays : dict, optional
            Specify delays of channels for synchronisation (+ve int), overriding DEFAULT_DELAY.
        print_params : bool, optional
            If True, print pulse parameters. Defaults to False.
        """
        self.ch_cfg = {}
        self.pulses = {}
        self.iq_data = {}
        self.dig_seq = {}

        self.const_power = const_power
        self.scale_power = scale_power

        default_delay = 0
        default_gain = 10000

        pulse_seqs = self.map_seqs(imported_seqs, ch_map) # Map sequences to appropriate channels

        self.check_chs(pulse_seqs) # Check channel strings are valid
        # self.check_delays(delays) # Check delay dictionary is valid
        self.check_gains(gains, pulse_seqs) # Check gain dictionary is valid

        for ch, seq_params in pulse_seqs.items():
            self.ch_cfg[ch] = {}
            self.pulses[ch] = {}

            # ch_type, ch_index
            self.ch_cfg[ch]["ch_type"], self.ch_cfg[ch]["ch_index"] = self.get_ch_type_index(ch)

            # delay
            self.ch_cfg[ch]["delay"] = delays.get(ch, default_delay)

            # gain
            if (self.ch_cfg[ch]["ch_type"] == "DAC") and (self.const_power is None):
                gain = gains.get(ch, default_gain)
                self.ch_cfg[ch]["gain"] = gain
            
            # Create pulse lists
            time = 0
            self.pulses[ch].update({"lengths":[], "times":[]})
            if self.ch_cfg[ch]["ch_type"] ==  "DAC":
                self.pulses[ch].update({"amps":[], "gains":[], "freqs":[], "phases":[], "styles":[], "outsels":[]})
                self.iq_data[ch] = {"idata":[], "qdata":[]}
            for params in seq_params:
                if isinstance(params, tuple): # Regular pulse
                    self.check_params(ch, params)
                    length_ns = params[0]
                    self.assign_pulse_params(params, ch, time)
                else: # Arb. pulse
                    length_ns = params.total_length
                    self.assign_arb_params(params, ch, time)
                time += length_ns
                
            # num_pulses, duration
            self.ch_cfg[ch]["num_pulses"] = len(self.pulses[ch]["lengths"]) # Number of pulses
            self.ch_cfg[ch]["duration"] = time/1e3 # End time of sequence [us]

        # end_time
        self.end_time = self.get_end_time()

        self.print_params(print_params)

    def map_seqs(self, imported_seqs, ch_map):
        """
        Maps imported sequences from pickle file to channels specified in dict 'ch_map'.

        Parameters
        ----------
        imported_seqs : list
            Pulse sequences to be generated by DACs and DIG outputs.
        ch_map : dict
            Map names of pulse sequences to channels on board.
        
        Returns
        -------
        dict
            Dictionary containing lists of tuples describing pulses. Keys mapped
            to correct channel names.
        """
        if ch_map != None:
            pulse_seqs = {}
            for key, value in ch_map.items():
                pulse_seqs[key] = imported_seqs[value]
        else:
            pulse_seqs = imported_seqs
        
        return pulse_seqs

    def check_chs(self, pulse_seqs):
        """
        Check if channel strings are valid.

        Parameters
        ----------
        pulse_seqs : dict
            Dictionary containing lists of tuples of pulse parameters for each channel.
        
        Raises
        ------
        KeyError
            Name of generator channel is not valid.
        """
        valid_chs = ["DAC_A", "DAC_B", "DIG_0", "DIG_1", "DIG_2", "DIG_3"]

        for ch in pulse_seqs:
            if ch not in valid_chs:
                raise KeyError(f"{ch} not a valid channel. Try any from {valid_chs}")

    def check_gains(self, gains, pulse_seqs):
        """
        Check if dict 'gains' has keys that are valid channels, and values that
        are ints or floats with a magnitude that is not greater than 30000.

        Parameters
        ----------
        gains : dict
            DAC channel gains.
        pulse_seqs : dict
            Dictionary containing lists of tuples of pulse parameters for each channel.
        
        Raises
        ------
        TypeError
            Gain is not an int or a float.
        ValueError
            Magnitude of gain exceeds 16383 when arbitrary DAC output is being produced.
        ValueError
            Magnitude of gain exceeds 32766 when no arbitrary DAC output is being produced.
        """
        for ch, gain in gains.items():
            if not isinstance(gain, (int, float)):
                raise TypeError(f"{ch} gain '{gain}' is a {type(gain)}. Must be a float or int")
            
            # TODO: Remove?
            if (abs(gain) > 16383) and (any(not isinstance(item, tuple) for item in pulse_seqs[ch])):
                raise ValueError(f"{ch} gain magnitude '{abs(gain)}' greater than 16383 (max when producing arb. pulses)")
            elif abs(gain) > 32766:
            # if abs(gain) > 32766:
                raise ValueError(f"{ch} gain magnitude '{abs(gain)}' greater than 32766")

    def check_delays(self, delays):
        """
        Check if dict 'delays' as keys that are valid channels, and values that
        are ints.

        Parameters
        ----------
        delays : dict
            Delays to be applied to generator channels for synchronisation.
        
        Raises
        ------
        TypeError
            Specified delay is not an integer.
        """
        for ch, delay in delays.items():
            if not isinstance(delay, int):
                raise TypeError(f"{ch} delay '{delay}' not integer number of clock cycles")

    def get_ch_type_index(self, ch):
        """
        Convert channel name string into a channel type (DAC or DIG) and an index.

        Parameters
        ----------
        ch : str
            Channel name.

        Returns
        -------
        str, int
            Channel type (DAC or DIG) and index.
        """
        ch_type = self.ch_cfg[ch]["ch_type"] = ch.split('_')[0]
        ch_ref = ch.split('_')[1]

        if ch_type == "DIG":
            ch_index = int(ch_ref)
        elif ch_type == "DAC":
            ch_index = {'A': 1, 'B': 0}.get(ch_ref)
        
        return ch_type, ch_index
    
    def check_params(self, ch, params):
        """
        Check if the correct number of parameters have been specified for each 
        pulse in array.

        Parameters
        ----------
        ch : str
            Name of generator channel.
        params : list
            Generator channel parameters.
        
        Raises
        ------
        IndexError
            Too many parameters specified for DAC or DIG channel during OFF period.
        Index Error
            Too many parameters specified for DAC or DIG channel during ON period.
        ValueError
            DAC amplitude must lie between 0 and 1.
        ValueError
            Parameter is not a float or an int.
        """

        if (bool(params[1]) == False) and (len(params) > 2):
            raise IndexError(f"Specified too many sequence parameters for pulse in channel {ch}")
        elif bool(params[1]) == True:
            if ((len(params) > 2) and (self.ch_cfg[ch]["ch_type"] == "DIG")
                or (len(params) > 4) and (self.ch_cfg[ch]["ch_type"] == "DAC")):
                raise IndexError(f"Specified too many sequence parameters for pulse in channel {ch}")
        
        if self.ch_cfg[ch]["ch_type"] == "DAC":
            if not 0 <= float(params[1]) <= 1.0:
                raise ValueError(f"Amplitude {float(params[1])} must be lie between 0 and 1")

        for param in params:
            if not isinstance(param, (float, int)):
                raise ValueError(f"Parameter {param} is a {type(param)}. Must be a float or int")
    
    def assign_pulse_params(self, params, ch, time):
        """
        Append pulse parameters contained in tuple (provided by user) to lists of 
        pulse parameters organised as a dictionary.

        Parameters
        ----------
        params : tuple
            Pulse parameters [period, amplitude, frequency, phase].
        ch : str
            Channel name.
        time : float
            Time at which pulse is triggered.
        """
        if bool(params[1]) == True: # A pulse exists
            self.pulses[ch]["times"].append(float(time/1e3)) # Trigger time [us]
            self.pulses[ch]["lengths"].append(float(params[0]/1e3)) # Pulse durations [us]

            if self.ch_cfg[ch]["ch_type"] == "DAC":
                ch_index = self.ch_cfg[ch]["ch_index"]
                freq = np.round(float(params[2]*1e3), 6)

                self.pulses[ch]["amps"].append(float(params[1])) # DAC amplitude
                if self.const_power is None:
                    self.pulses[ch]["gains"].append(int(self.ch_cfg[ch]["gain"] * self.pulses[ch]["amps"][-1]))
                else:
                    self.pulses[ch]["gains"].append(int(self.scale_power * self.interpolate_dict(self.const_power, freq) * self.pulses[ch]["amps"][-1]))
                if self.pulses[ch]["gains"][-1] > 32566:
                    raise ValueError(f"Pulse gain is {self.pulses[ch]['gains'][-1]} but should not exceed 32566")
                self.pulses[ch]["freqs"].append(freq) # DAC frequency [Hz]
                self.pulses[ch]["styles"].append('const')

                self.pulses[ch]["outsels"].append(None)
                self.iq_data[ch]["idata"].append(None)
                self.iq_data[ch]["qdata"].append(None)

                phase = float(params[3])
                self.pulses[ch]["phases"].append(phase) # DAC phase [deg]

    def assign_arb_params(self, params, ch, time):
        """
        Append pulse parameters contained in abitrary pulse object to lists of 
        pulse parameters organised as a dictionary.

        Parameters
        ----------
        params : object
            Arbitrary pulse object.
        ch : str
            Channel name.
        time : float
            Time at which pulse is to be triggered.
        """
        self.pulses[ch]["times"].append(float(time/1e3))
        self.pulses[ch]["lengths"].append(float(params.total_length/1e3))
        # self.pulses[ch]["gains"].append(int(self.ch_cfg[ch]["gain"]))
        # TODO: Custom gain
        if self.const_power is None:
            self.pulses[ch]["gains"].append(int(self.ch_cfg[ch]["gain"]*2))
        else:
            self.pulses[ch]["gains"].append(int(self.scale_power * self.interpolate_dict(self.const_power, params.freq*1e3)*2))
        if self.pulses[ch]["gains"][-1] > 32566:
            raise ValueError(f"Arb. pulse gain is {self.pulses[ch]['gains'][-1]} but should not exceed 32566")
        self.pulses[ch]["outsels"].append(params.outsel)
        self.pulses[ch]["freqs"].append(np.round(float(params.freq*1e3), 6))
        self.pulses[ch]["styles"].append('arb')

        self.pulses[ch]["amps"].append(None)
        self.pulses[ch]["phases"].append(None)

        self.iq_data[ch]["idata"].append(params.idata)
        self.iq_data[ch]["qdata"].append(params.qdata)

    def get_end_time(self):
        """
        Find time at which longest sequence ends and assign corresponding class
        variable 'end_time'.

        Returns
        -------
        float
            Maximum end-time of channel producing pulses.
        """
        # Find and print time at which longest sequence ends
        end_times = [self.ch_cfg[ch]["duration"] for ch in self.ch_cfg]

        if not all(i == end_times[0] for i in end_times):
            print(f"WARNING: Not all sequences are of the same duration: {end_times}")
        
        return max(end_times)
    
    def print_params(self, enabled):
        """
        Prints dictionary containing pulse parameters for each channel. Useful for debugging.

        Parameters
        ----------
        enabled : bool
            If True, print pulse parameters.
        """
        if enabled:
            for ch in self.ch_cfg:
                if self.ch_cfg[ch]["ch_type"] == "DIG":
                    print(f"\n---------- DIG {self.ch_cfg[ch]['ch_index']} ----------")
                elif self.ch_cfg[ch]["ch_type"] == "DAC":
                    if self.ch_cfg[ch]['ch_index'] == 1:
                        print(f"\n---------- DAC A ----------")
                    elif self.ch_cfg[ch]['ch_index'] == 0:
                        print(f"\n---------- DAC B ----------")

                print("CONFIG")
                for key, value in self.ch_cfg[ch].items():
                    print(f"\t{key}: {value}")
                
                print("PULSES")
                for key, value in self.pulses[ch].items():
                    print(f"\t{key}: {value}")

            print(f"\nEND TIME: {self.end_time}")

    def generate_asm(self, prog, reps=1):
        """
        Generate tproc assembly that produces appropriately timed pulses 
        according to parameters specified in parsed lists.

        Parameters
        ----------
        prog : class
            Instructions to be executed by tproc.
        reps : int, optional
            Number of times the pulse sequence is to be repeated. Defaults to 1.
        """
        ch_cfg = self.ch_cfg

        prog.synci(200)  # Give processor some time to configure pulses
        prog.regwi(0, 14, reps - 1) # 10 reps, stored in page 0, register 14
        prog.label("LOOP_I") # Start of internal loop

        for ch in ch_cfg:
            if ch_cfg[ch]["ch_type"] == "DAC":
                self.gen_dac_asm(prog, ch)
            elif ch_cfg[ch]["ch_type"] == "DIG":
                self.gen_dig_seq(prog, ch)

        self.gen_dig_asm(prog)

        # prog.wait_all() # TODO: Is this necessary? Pause tproc until all channels finished sequences
        prog.synci(prog.us2cycles(self.end_time)) # Sync all channels when last channel finished sequence
        prog.loopnz(0, 14, "LOOP_I") # End of internal loop
        prog.end()

    def gen_dac_asm(self, prog, ch):
        """
        DAC specific assembly instructions for use in generate_asm()

        Parameters
        ----------
        prog : object
            Instructions to be executed on tproc.
        ch : str
            Name of generator channel.
        """
        ch_cfg = self.ch_cfg[ch]
        pulses = self.pulses[ch]

        ch_index = ch_cfg["ch_index"]

        # Initialise DAC
        prog.declare_gen(ch=ch_index, nqz=1) 

        for i in range(ch_cfg["num_pulses"]):
            # Time
            time_us = pulses["times"][i]
            if i > 0:
                if round(time_us, 9) > round(pulses["times"][i-1] + pulses["lengths"][i-1], 9):
                    time = prog.us2cycles(time_us) + ch_cfg["delay"]
                else:
                    time = "auto"
            else:
                time = prog.us2cycles(time_us) + ch_cfg["delay"]
            # Freq
            freq = prog.freq2reg(pulses["freqs"][i], gen_ch=ch_index)
            # Gain
            gain = pulses["gains"][i]

            # Style specific
            if pulses["styles"][i] == 'const':
                # Phase
                phase_deg = pulses["phases"][i]
                phase = prog.deg2reg(phase_deg, gen_ch=ch_index)
                # Length
                length_us = pulses["lengths"][i]
                length = prog.us2cycles(length_us, gen_ch=ch_index)
                # Program registers
                prog.set_pulse_registers(ch=ch_index, gain=gain, freq=freq, phase=phase, style="const", length=length)
            elif pulses["styles"][i] == 'arb':
                # Phase
                phase = prog.deg2reg(0, gen_ch=ch_index)
                # Outsel
                outsel = pulses["outsels"][i]
                # IQ data
                arb_name = "arb" + str(i)
                idata = self.iq_data[ch]["idata"][i]
                qdata = self.iq_data[ch]["qdata"][i]
                # Program registers
                prog.add_envelope(ch=ch_index, name=arb_name, idata=idata, qdata=qdata)
                prog.set_pulse_registers(ch=ch_index, gain=gain, freq=freq, phase=phase, style="arb", waveform=arb_name, outsel=outsel)

                # TODO: Add warning if IQ gain exceeds 32566

            # Play DAC pulse
            prog.pulse(ch=ch_index, t=time)

    def gen_dig_seq(self, prog, ch):
        """
        Create class dict 'dig_seq' containing all digital pulse parameters.

        Parameters
        ----------
        prog : object
            Instructions to be executed on tproc.
        ch : str
            Name of generator channel.
        """
        ch_cfg = self.ch_cfg[ch]
        pulses = self.pulses[ch]

        ch_index = ch_cfg["ch_index"]

        for i in range(ch_cfg["num_pulses"]):
            # DIG pulse length 
            length = prog.us2cycles(pulses["lengths"][i])
            # DIG pulse start time
            time = prog.us2cycles(pulses["times"][i]) + ch_cfg["delay"]
            # Add beginning of DIG pulse
            if time in self.dig_seq:
                self.dig_seq[time].append((ch_index, True))
            else:
                self.dig_seq[time] = [(ch_index, True)]
            # Add end of DIG pulse
            if time+length in self.dig_seq:
                self.dig_seq[time+length].append((ch_index, False))
            else:
                self.dig_seq[time+length] = [(ch_index, False)]

        # Not strictly necessary but makes inspecting assembly easier
        self.dig_seq = dict(sorted(self.dig_seq.items()))

    def gen_dig_asm(self, prog):
        """
        Digital output specific assembly instructions for use in generate_asm()

        Parameters
        ----------
        prog : object
            Instructions to be executed on tproc.
        """
        soccfg = prog.soccfg

        # Program DIG after all channels have been configured
        rp, r_out = 0, 31 # tproc register page, tproc register
        dig_id = soccfg['tprocs'][0]['output_pins'][0][1]

        r_val = 0
        for time, states in self.dig_seq.items():
            for l in states:
                ch_index = l[0]
                state = l[1]

                # Set appropriate bits in register to reflect desired output state
                if state == True:
                    r_val |= (1 << ch_index)
                elif state == False:
                    r_val &= ~(1 << ch_index)

            prog.regwi(rp, r_out, r_val) # Write to register
            prog.seti(dig_id, rp, r_out, time) # Assign digital output

    def config_internal_start(self, soc, prog, load_pulses=True, reset=False):
        """
        Configure the tproc for internal triggering using the soc.tproc.start() function.

        Parameters
        ----------
        soc : object
            RFSoC object.
        prog : object
            Instructions to be executed on tproc.
        load_pulses : bool, optional
            Load pulses from program into RFSoC.
        reset : bool, optional
            Stop the tproc.
        """
        if prog.binprog is None:
            prog.compile()

        soc.start_src("internal")
        soc.stop_tproc(lazy=not reset)

        if load_pulses:
            prog.load_pulses(soc)
        prog.config_gens(soc)
        prog.config_readouts(soc)

        soc.load_bin_program(prog.binprog)

    def config_external_start(self, soc, prog, load_pulses=True, reset=False):
        """
        Configure the tproc for external triggering using PMOD1_0.

        Parameters
        ----------
        soc : object
            RFSoC object.
        prog : object
            Instructions to be executed on tproc.
        load_pulses : bool, optional
            Load pulses from program into RFSoC.
        reset : bool, optional
            Stop the tproc.
        """
        if prog.binprog is None:
            prog.compile()

        soc.start_src("external")
        soc.stop_tproc(lazy=not reset)

        if load_pulses:
            prog.load_pulses(soc)
        prog.config_gens(soc)
        prog.config_readouts(soc)

        soc.load_bin_program(prog.binprog)
    

    def interpolate_dict(self, param_dict, freq):
        i = bisect.bisect_left(list(param_dict.keys()), freq)
        freq_above = list(param_dict.keys())[i]
        val_above = param_dict[list(param_dict.keys())[i]]
        freq_below = list(param_dict.keys())[i-1]
        val_below = param_dict[list(param_dict.keys())[i-1]]

        val = (val_below + (((freq - freq_below) / (freq_above - freq_below)) * (val_above - val_below)))

        return val 